import os
import json
import time

def getToken(Auth_name, file_cert, file_key, Namespace, url_vault):
    try:
        token_file = "vault_token.json"
        
        # Vérifie si un fichier de token existe
        if os.path.exists(token_file):
            with open(token_file, "r") as file:
                token_data = json.load(file)
            expiration_time = token_data.get("expiration_time", 0)
            
            # Vérifie si le token est encore valide
            if expiration_time > time.time():
                print("Utilisation du token existant.")
                return token_data["token"]

        headers = {
            "Content-Type": "application/x-www-form-urlencoded"
        }
        
        cert = (file_cert, file_key)
        data = json.dumps({"name": Auth_name})
        url = url_vault + "v1/" + Namespace + "/auth/cert_qual/login"
        
        print("url:", url)
        print("data:", data)
        
        response = requests.post(url, headers=headers, data=data, cert=cert, verify=False)
        print("response:", response)
        
        request = response.json()
        print("request:", request)
        
        Token = request.get("auth").get("client_token")
        
        # Sauvegarde le token dans un fichier temporaire
        expiration_time = time.time() + request.get("auth").get("lease_duration")
        token_data = {"token": Token, "expiration_time": expiration_time}
        with open(token_file, "w") as file:
            json.dump(token_data, file)
        
        return Token
    except Exception as e:
        print("Une erreur s'est produite lors de la récupération du token:", str(e))
        return None




import time

def getToken(Auth_name, file_cert, file_key, Namespace, url_vault):
    try:
        headers = {
            "Content-Type": "application/x-www-form-urlencoded"
        }
        cert = (file_cert, file_key)
        data = {
            "name": Auth_name
        }
        url = url_vault + "v1/" + Namespace + "/auth/cert_qual/login"
        print("url:", url)
        print("data:", data)
        print("cert", cert)
        response = requests.post(url, headers=headers, data=data, cert=cert, verify=False)
        print("response:", response)
        request = response.json()
        print("request:", request)
        
        # Vérifier le TTL du token
        Token = request.get("auth").get('client_token')
        ttl = request.get("auth").get('lease_duration')
        
        # Vérifier si le token a expiré
        if ttl > 0:
            current_time = int(time.time())
            expiration_time = current_time + ttl
            if expiration_time > current_time:
                return Token  # Le token est valide, renvoyer le même token
        
        # Le token a expiré, récupérer un nouveau token
        print("Le token a expiré. Récupération d'un nouveau token.")
        new_token = requestNewToken(Auth_name, file_cert, file_key, Namespace, url_vault)
        return new_token
    except Exception as e:
        print("Une erreur s'est produite :", str(e))
        return None  # Gérer l'erreur comme vous le souhaitez

# Fonction pour récupérer un nouveau token
def requestNewToken(Auth_name, file_cert, file_key, Namespace, url_vault):
    # Mettez ici votre code pour récupérer un nouveau token, similaire à la fonction getToken
    # Vous pouvez appeler cette fonction depuis getToken lorsque le token a expiré
    pass









import sys
import requests
import datetime  # Importez le module datetime pour travailler avec les dates

# Cette variable stocke la date d'expiration du token
expiration_date = None

def getToken(Auth_name, file_cert, file_key, Namespace, url_vault):
    global expiration_date  # Utilisez une variable globale pour stocker la date d'expiration

    try:
        headers = {
            "Content-Type": "application/x-www-form-urlencoded"
        }
        cert = (file_cert, file_key)
        data = {
            "name": Auth_name
        }
        url = url_vault + "v1/" + Namespace + "/auth/cert_qual/login"
        
        # Vérifiez si le token a expiré ou si la date d'expiration est inconnue
        if expiration_date is None or datetime.datetime.now() > expiration_date:
            print("Obtention d'un nouveau token...")
            response = requests.post(url, headers=headers, data=data, cert=cert, verify=False)
            print("response:", response)
            request = response.json()
            Token = request.get("auth").get('client_token')
            
            # Définissez la nouvelle date d'expiration du token (par exemple, 1 heure à partir de maintenant)
            expiration_date = datetime.datetime.now() + datetime.timedelta(hours=1)
            
            print("Nouveau token obtenu.")
        else:
            print("Utilisation du token existant.")
            Token = None  # Utilisez le token existant
        
        return Token
    except Exception as e:
        print("Une erreur s'est produite lors de l'obtention du token :", e)
        return None

# Appel de la fonction getToken pour obtenir le token
# Vous pouvez maintenant appeler cette fonction chaque fois que vous avez besoin d'un token







import hvac
import time

# Configuration Vault
vault_url = 'http://adresse-de-vault:8200'  # Remplacez par l'URL de votre instance Vault
cert_path = '/chemin/vers/votre/certificat.pem'
key_path = '/chemin/vers/votre/cle-privée.pem'
ca_path = '/chemin/vers/votre/autorité-de-certification.pem'

# Variables de token
vault_token = None
token_expiry = 0

# Durée en secondes avant l'expiration du token pour renouveler
token_renew_threshold = 300  # Par exemple, 5 minutes avant expiration

# Fonction pour récupérer un token
def get_token():
    client = hvac.Client(url=vault_url, cert=(cert_path, key_path), verify=ca_path)
    response = client.auth.cert.login()
    if response is not None and 'auth' in response and 'client_token' in response['auth']:
        return response['auth']['client_token']
    else:
        raise Exception('Impossible de récupérer le token depuis Vault.')

# Fonction pour vérifier si le token expire
def is_token_expired():
    global token_expiry
    current_time = time.time()
    return token_expiry <= current_time

# Fonction pour obtenir le token, en le renouvelant si nécessaire
def get_or_renew_token():
    global vault_token
    global token_expiry

    if vault_token is None or is_token_expired():
        vault_token = get_token()
        token_info = hvac.Client(url=vault_url, token=vault_token, verify=ca_path).lookup_token()
        token_expiry = token_info['data']['expire_time']

    return vault_token

# Fonction pour extraire le mot de passe de connexion PostgreSQL depuis Vault
def get_postgres_credentials():
    token = get_or_renew_token()
    client = hvac.Client(url=vault_url, token=token, verify=ca_path)
    postgres_credentials = client.read('path/to/postgres/secret')  # Remplacez par le chemin approprié dans Vault
    if postgres_credentials is not None and 'data' in postgres_credentials:
        return postgres_credentials['data']
    else:
        raise Exception('Impossible de récupérer les informations PostgreSQL depuis Vault.')

# Fonction principale
def main():
    postgres_credentials = get_postgres_credentials()
    
    # Utilisez postgres_credentials pour établir une connexion à la base de données PostgreSQL

if __name__ == '__main__':
    main()





import os
import json

# Variables pour mettre en cache le token et le mot de passe
TOKEN_CACHE = None
PASSWORD_CACHE = None

def get_token(cmd):
    global TOKEN_CACHE

    # Si le token est déjà dans le cache, le retourner directement
    if TOKEN_CACHE:
        return TOKEN_CACHE

    stream = os.popen(cmd)
    output = stream.read()
    json_output = json.loads(output)
    TOKEN_CACHE = json_output["auth"]["client_token"]
    return TOKEN_CACHE

def get_pw(cmd):
    global PASSWORD_CACHE

    # Si le mot de passe est déjà dans le cache, le retourner directement
    if PASSWORD_CACHE:
        return PASSWORD_CACHE

    stream = os.popen(cmd)
    output = stream.read()
    json_output = json.loads(output)
    PASSWORD_CACHE = json_output["data"]["password"]
    return PASSWORD_CACHE

cert_pfx = "/apps/learoit/vault/ap08374-auth-hprod-learnit.crt"
cert_key = "/apps/learoit/vault/ap08374-auth-hprod-learnit.key"
json_token_cmd = f"curl --cert {cert_pfx} --key {cert_key} -d 'name=auth-learnit'"

BU = "DATA"
BL = "BIT"
Ecosystem = "EC012100171"
PostgresInst = "pg081003199"
PostgresUser = "static-stage"
url_vault = "https://hvault.staging.echonet"

url_login = f"{url_vault}/v1/{BU}/{BL}/{Ecosystem}/auth/cert/login"
cmd_login = f"{json_token_cmd} {url_login}"
token = get_token(cmd_login)

url_pw = f"{url_vault}/v1/database/postgres/{PostgresInst}/static-creds/{PostgresUser}"
cmd_pw = f"curl -H 'Accept: */*' -H 'X-Vault-Token: {token}' -H 'X-Vault-Namespace: {BU}/{BL}/{Ecosystem}' -H 'X-Vault-Request: true' {url_pw}"
password = get_pw(cmd_pw)

print(password)

{
  "users": [
      {
          "i_uid": {
              "email": "famienleroi.amoin@gmail.com",
              "name": "Famien Le Roi AMOIN",
              "uid": "f45933"
          },
          "tenant": "tenant_1",
          "profil": "Designer",
          "groupes": ["groupe_1", "groupe_2"],
          "admin": True
      },
      {
          "i_uid": {
              "email": "example@example.com",
              "name": "John Doe",
              "uid": "f45934"
          },
          "tenant": "tenant_2",
          "profil": "Reader",
          "groupes": ["groupe_3"],
          "admin": False
      }
  ]
}




def insertion_user(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNinL1H4r03oyginesbSmSpXbIN", no_check_certificate=True)
    
    # CIA de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "dataset_habillitation_marketplace"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    results = []

    for user in users:
        i_UID = user.get("i_UID")
        profil = user.get("profil")
        admin = user.get("admin")
        tenant = user.get("tenant")
        groupe = user.get("groupe")

        if i_UID in current_data['i_UID'].values:
            results.append({"i_UID": i_UID, "status": "error", "message": "🚫 L'ID utilisateur '{}' existe déjà.".format(i_UID)})
            continue

        if profil not in ["Reader", "Designer"]:
            results.append({"i_UID": i_UID, "status": "error", "message": "🚫 Profil '{}' non valide.".format(profil)})
            continue

        if not isinstance(admin, bool):
            results.append({"i_UID": i_UID, "status": "error", "message": "🚫 Valeur admin invalide."})
            continue

        # Incrémenter l'ID
        if current_data.empty or pd.isna(current_data['id'].max()):
            new_id = 1
        else:
            new_id = current_data['id'].max() + 1

        current_data = current_data.append({
            "id": new_id,
            "Tenant": tenant,
            "i_UID": i_UID,
            "Profil": profil,
            "Groupes": groupe,
            "Admin": admin
        }, ignore_index=True)

        results.append({"i_UID": i_UID, "status": "success", "message": "✅ Utilisateur '{}' ajouté.".format(i_UID)})

    # Mise à jour de la base de données
    dataset.write_with_schema(current_data)

    # Convertir les résultats en dataframe pour affichage sous forme de tableau
    return pd.DataFrame(results)





def insertion_user(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNinL1H4r03oyginesbSmSpXbIN", no_check_certificate=True)
    
    # CIA de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "dataset_habillitation_marketplace"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    results = []

    for user in users:
        i_UID = user.get("i_UID")
        profil = user.get("profil")
        admin = user.get("admin")
        tenant = user.get("tenant")
        groupe = user.get("groupe")

        # Vérifier si l'ID de l'utilisateur existe déjà
        if i_UID in current_data['i_UID'].values:
            results.append({"i_UID": i_UID, "status": "error", "message": "ID User already exists in the dataset."})
            continue

        # Vérification du profil
        if profil not in ["Reader", "Designer"]:
            results.append({"i_UID": i_UID, "status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."})
            continue

        # Vérification du statut admin
        if not isinstance(admin, bool):
            results.append({"i_UID": i_UID, "status": "error", "message": "Admin value should be a boolean (True or False)."})
            continue

        # Incrémenter l'ID
        if current_data.empty or pd.isna(current_data['id'].max()):
            new_id = 1
        else:
            new_id = current_data['id'].max() + 1

        # Ajouter la nouvelle ligne à la liste des nouvelles entrées
        current_data = current_data.append({
            "id": new_id,
            "Tenant": tenant,
            "i_UID": i_UID,
            "Profil": profil,
            "Groupes": groupe,
            "Admin": admin
        }, ignore_index=True)

        results.append({"i_UID": i_UID, "status": "success", "message": "Data added successfully."})

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(current_data)

    return results






def insertion_user(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNinL1H4r03oyginesbSmSpXbIN", no_check_certificate=True)
    
    # Clé de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "dataset_habillitation_marketplace"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    new_rows = []
    results = []

    for user in users:
        i_UID = user.get("i_UID")
        profil = user.get("profil")
        admin = user.get("admin")
        tenant = user.get("tenant")
        groupe = user.get("groupe")

        if not all([i_UID, profil, admin, tenant, groupe]):
            results.append({"status": "error", "message": "Some required fields are missing for one of the users."})
            continue

        if i_UID in current_data['i_UID'].values:
            results.append({"i_UID": i_UID, "status": "error", "message": "ID User already exists in the dataset."})
            continue

        if profil not in ["Reader", "Designer"]:
            results.append({"i_UID": i_UID, "status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."})
            continue

        if not isinstance(admin, bool):
            results.append({"i_UID": i_UID, "status": "error", "message": "Admin value should be a boolean (True or False)."})
            continue

        # Incrémenter l'ID
        if current_data.empty or pd.isna(current_data['id'].max()):
            new_id = 1
        else:
            new_id = current_data['id'].max() + 1

        # Ajouter la nouvelle ligne à la liste des nouvelles entrées
        new_rows.append({
            "id": new_id,
            "Tenant": tenant,
            "i_UID": i_UID,
            "Profil": profil,
            "Groupes": groupe,
            "Admin": admin
        })

        results.append({"i_UID": i_UID, "status": "success", "message": "Data added successfully"})

    # Convertir la liste des nouvelles entrées en DataFrame
    new_data = pd.DataFrame(new_rows)

    # Ajouter les nouvelles lignes au DataFrame existant
    updated_data = pd.concat([current_data, new_data], ignore_index=True)

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return results






def insertion_user(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNinL1H4r03oyginesbSmSpXbIN", no_check_certificate=True)
    
    # Clé de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "dataset_habillitation_marketplace"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    new_rows = []
    results = []

    for user in users:
        i_UID = user.get("i_UID")
        profil = user.get("profil")
        admin = user.get("admin")
        tenant = user.get("tenant")
        groupe = user.get("groupe")

        if i_UID in current_data['i_UID'].values:
            results.append({"i_UID": i_UID, "status": "error", "message": "ID User already exists in the dataset."})
            continue

        if profil not in ["Reader", "Designer"]:
            results.append({"i_UID": i_UID, "status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."})
            continue

        if not isinstance(admin, bool):
            results.append({"i_UID": i_UID, "status": "error", "message": "Admin value should be a boolean (True or False)."})
            continue

        # Incrémenter l'ID
        if current_data.empty or pd.isna(current_data['id'].max()):
            new_id = 1
        else:
            new_id = current_data['id'].max() + 1

        # Ajouter la nouvelle ligne à la liste des nouvelles entrées
        new_rows.append({
            "id": new_id,
            "Tenant": tenant,
            "i_UID": i_UID,
            "Profil": profil,
            "Groupes": groupe,
            "Admin": admin
        })

        results.append({"i_UID": i_UID, "status": "success", "message": "Data added successfully"})

    # Convertir la liste des nouvelles entrées en DataFrame
    new_data = pd.DataFrame(new_rows)

    # Ajouter les nouvelles lignes au DataFrame existant
    updated_data = pd.concat([current_data, new_data], ignore_index=True)

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return results




def insertion_user(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNinL1H4r03oyginesbSmSpXbIN", no_check_certificate=True)
    
    # Clé de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "dataset_habillitation_marketplace"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    results = []

    for user in users:
        i_UID = user.get("i_UID")
        profil = user.get("profil")
        admin = user.get("admin")
        tenant = user.get("tenant")
        groupe = user.get("groupe")

        if i_UID in current_data['i_UID'].values:
            results.append({"i_UID": i_UID, "status": "error", "message": "ID User already exists in the dataset."})
            continue

        if profil not in ["Reader", "Designer"]:
            results.append({"i_UID": i_UID, "status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."})
            continue

        if not isinstance(admin, bool):
            results.append({"i_UID": i_UID, "status": "error", "message": "Admin value should be a boolean (True or False)."})
            continue

        # Incrémenter l'ID
        if current_data.empty or pd.isna(current_data['id'].max()):
            new_id = 1
        else:
            new_id = current_data['id'].max() + 1

        # Créer un DataFrame pour l'utilisateur actuel
        new_data = pd.DataFrame([{
            "id": new_id,
            "Tenant": tenant,
            "i_UID": i_UID,
            "Profil": profil,
            "Groupes": groupe,
            "Admin": admin
        }])

        # Écrire la nouvelle entrée dans le dataset
        dataset.write_with_schema(new_data)

        # Ajouter un rapport de succès pour cet utilisateur
        results.append({"i_UID": i_UID, "status": "success", "message": "Data added successfully"})

    return results







def insertion_user(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNinL1H4r03oyginesbSmSpXbIN", no_check_certificate=True)
    
    # CIA de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "dataset_habillitation_marketplace"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    new_rows = []

    for user in users:
        i_UID = user.get("i_UID")
        profil = user.get("profil")
        admin = user.get("admin")
        tenant = user.get("tenant")
        groupe = user.get("groupe")

        if i_UID in current_data['i_UID'].values:
            return {"status": "error", "message": "ID User already exists in the dataset."}

        if profil not in ["Reader", "Designer"]:
            return {"status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."}

        if not isinstance(admin, bool):
            return {"status": "error", "message": "Admin value should be a boolean (True or False)."}

        # Incrémenter l'ID
        if current_data.empty or pd.isna(current_data['id'].max()):
            new_id = 1
        else:
            new_id = current_data['id'].max() + 1

        # Ajouter la nouvelle ligne à la liste des nouvelles entrées
        new_rows.append({
            "id": new_id,
            "Tenant": tenant,
            "i_UID": i_UID,
            "Profil": profil,
            "Groupes": groupe,
            "Admin": admin
        })

    # Convertir la liste des nouvelles entrées en DataFrame
    new_data = pd.DataFrame(new_rows)

    # Ajouter les nouvelles lignes au DataFrame existant
    updated_data = pd.concat([current_data, new_data], ignore_index=True)

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return {"status": "success", "message": "Data added successfully"}







def api_py_function(users):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # ... [la même initialisation que vous avez déjà] ...

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    new_rows = []

    for user in users:
        # Vérifiez les entrées pour chaque utilisateur
        uid = user.get("i_UID")
        email = user.get("profil")
        admin = user.get("admin")
        profile = user.get("groupe")

        if email in current_data['profil'].values:
            return {"status": "error", "message": f"Email {email} already exists in the dataset."}

        if uid in current_data['i_UID'].values:
            return {"status": "error", "message": f"UID {uid} already exists in the dataset."}

        if profile not in ["Reader", "Designer"]:
            return {"status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."}

        if not isinstance(admin, bool):
            return {"status": "error", "message": "Admin value should be a boolean (True or False)."}

        # Si tout est correct, ajoutez l'utilisateur à la liste des nouvelles lignes
        new_rows.append(user)

    # Convertir la liste des nouvelles lignes en DataFrame
    new_data = pd.DataFrame(new_rows)

    # Ajouter les nouvelles lignes au Dataframe actuel
    updated_data = pd.concat([current_data, new_data], ignore_index=True)

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return {"status": "success", "message": "Data added successfully"}


[
    {
        "tenant": "example_tenant1",
        "i_UID": "user901",
        "profil": "john.doe@example.com",
        "groupe": "Reader",
        "admin": true
    },
    {
        "tenant": "example_tenant2",
        "i_UID": "user902",
        "profil": "jane.doe@example.com",
        "groupe": "Designer",
        "admin": false
    }
]





# Vérifiez le profil et le statut admin
    if profile not in ["Reader", "Designer"]:
        return {"status": "error", "message": "Invalid profile value. Accepted values are 'Reader' or 'Designer'."}
    
    if not isinstance(admin, bool):
        return {"status": "error", "message": "Admin value should be a boolean (True or False)."}




def api_py_function(id, uid_user, first_name, last_name, email, profile):
    import dataikuapi
    import pandas as pd
    import urllib3
    import dataiku

    # Désactiver l'avertissement SSL
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    # Configuration Dataiku
    dataiku.set_remote_dss("https://s02v19900033.fr.net.intra:10443", "hnleqTNWnL1H4r03oygjnesbSmSpXbIN", no_check_certificate=True)

    # CIA de votre projet Dataiku
    project_key = "API_MARKETPLACE"

    # Nom de votre dataset
    dataset_name = "test_prepared"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    # Vérifier si l'email ou l'uid_user existe déjà
    if email in current_data['email'].values:
        return {"status": "error", "message": "Email already exists in the dataset."}

    if uid_user in current_data['uid_user'].values:
        return {"status": "error", "message": "UID User already exists in the dataset."}
    if current_data.empty or pd.isna(current_data['id'].max()):
        new_id = 1
    else:
        new_id = current_data['id'].max() + 1
    # Ajouter une nouvelle ligne
    new_row = pd.DataFrame({
        "id": [id],
        "uid_user": [uid_user],
        "first_name": [first_name],
        "last_name": [last_name],
        "email": [email],
        "profile": [profile]
    })

    # Ajouter la nouvelle ligne au Dataframe
    updated_data = pd.concat([current_data, new_row], ignore_index=True)

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return {"status": "success", "message": "Data added successfully"}





# Import des modules nécessaires
import dataiku
import pandas as pd

# Fonction pour l'endpoint
def add_new_data(request):
    # Extraction des données de la requête
    data = request.get_json()
    
    # Spécifiez le projet et le dataset
    project_key = "API_MARKETPLACE"
    dataset_name = "test_prepared"

    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)

    # Charger les données actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    # Construire la nouvelle ligne à partir de la requête
    new_row = pd.DataFrame({
        "id": [data['id']],
        "uid_user": [data['uid_user']],
        "first_name": [data['first_name']],
        "last_name": [data['last_name']],
        "email": [data['email']],
        "profile": [data['profile']]
    })

    # Ajouter la nouvelle ligne au Dataframe
    current_data = pd.concat([current_data, new_row], ignore_index=True)

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(current_data)
    
    return {"status": "success", "message": "Data added successfully"}




{
    "id": 32,
    "uid_user": "user888",
    "first_name": "John",
    "last_name": "Doe",
    "email": "johndoe@gmail.com",
    "profile": "Reader"
}







import dataiku
import pandas as pd

def add_row_to_dataiku_dataset(id, uid_user, first_name, last_name, email, profile):
    """
    Ajoute une nouvelle ligne à un dataset Dataiku.

    Args:
    - id (int): ID de l'utilisateur.
    - uid_user (str): UID de l'utilisateur.
    - first_name (str): Prénom de l'utilisateur.
    - last_name (str): Nom de famille de l'utilisateur.
    - email (str): Email de l'utilisateur.
    - profile (str): Profil de l'utilisateur.

    Returns:
    - DataFrame: Le dataset mis à jour.
    """
    # Configuration Dataiku
    dataiku.set_remote_dss("https://dataiku-demo.dev-echonet/","InWeqTNWnL1H4r03oygjnesbSmSpXbIN",no_check_certificate=True)

    # CIA de votre projet Dataiku
    project_key = "API_MARKETPLACE"
    
    # Nom de votre dataset
    dataset_name = "test_prepared"
    
    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)
    
    # Charger les donnes actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    # Afficher les données actuelles
    print("Données actuelles:")
    print(current_data.head())
    print("...")

    # Créer un DataFrame pour la nouvelle ligne à partir des paramètres
    new_row_df = pd.DataFrame({
        "id": [id],
        "uid_user": [uid_user],
        "first_name": [first_name],
        "last_name": [last_name],
        "email": [email],
        "profile": [profile]
    })

    # Ajouter la nouvelle ligne au Dataframe
    updated_data = pd.concat([current_data, new_row_df], ignore_index=True)

    # Afficher les données mises à jour
    print("\nDonnées après l'ajout:")
    print(updated_data.tail())
    print("...")

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return updated_data

# Utilisation de la fonction
add_row_to_dataiku_dataset(31, "user777", "newuser", "newuser", "newuser@gmail.com", "Reader")






import dataiku
import pandas as pd

def add_row_to_dataiku_dataset(new_row_data):
    """
    Ajoute une nouvelle ligne à un dataset Dataiku.

    Args:
    - new_row_data (dict): Données de la nouvelle ligne à ajouter.

    Returns:
    - DataFrame: Le dataset mis à jour.
    """
    # Configuration Dataiku
    dataiku.set_remote_dss("https://dataiku-demo.dev-echonet/","InWeqTNWnL1H4r03oygjnesbSmSpXbIN",no_check_certificate=True)

    # CIA de votre projet Dataiku
    project_key = "API_MARKETPLACE"
    
    # Nom de votre dataset
    dataset_name = "test_prepared"
    
    # Obtenir le dataset
    dataset = dataiku.Dataset(dataset_name, project_key)
    
    # Charger les donnes actuelles du dataset dans un DataFrame
    current_data = dataset.get_dataframe()

    # Afficher les données actuelles
    print("Données actuelles:")
    print(current_data.head())
    print("...")

    # Convertir le dictionnaire new_row_data en DataFrame
    new_row_df = pd.DataFrame(new_row_data)

    # Ajouter la nouvelle ligne au Dataframe
    updated_data = pd.concat([current_data, new_row_df], ignore_index=True)

    # Afficher les données mises à jour
    print("\nDonnées après l'ajout:")
    print(updated_data.tail())
    print("...")

    # Redécrire les données mises à jour dans le dataset
    dataset.write_with_schema(updated_data)

    return updated_data

# Utilisation de la fonction
new_data = {
    "id": [31],
    "uid_user": ["user777"],
    "first_name": ["newuser"],
    "last_name": ["newuser"],
    "email": ["newuser@gmail.com"],
    "profile": ["Reader"]
}
add_row_to_dataiku_dataset(new_data)



*******


import dataiku
import dataikuapi
import pandas as pd
import urllib3

# Désactiver l'avertissement SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Configuration Dataiku
dataiku.set_remote_dss("https://dataiku-demo.dev-echonet/", "InWeqTNWnL1H4r03oygjnesbSmSpXbIN", no_check_certificate=True)

# CIA de votre projet Dataiku
project_key = "API_MARKETPLACE"

# Nom de votre dataset
dataset_name = "test_prepared"

# Obtenir le dataset
dataset = dataiku.Dataset(dataset_name, project_key)

# Charger les données actuelles du dataset dans un DataFrame
current_data = dataset.get_dataframe()

# Afficher les données actuelles
print("Données actuelles:")
print(current_data.head())
print("...")

# Ajouter une nouvelle ligne
new_row = pd.DataFrame({
    "id": [31],
    "uid_user": ["user777"],
    "first_name": ["newuser"],
    "last_name": ["newuser"],
    "email": ["newuser@gmail.com"],
    "profile": ["Reader"]
})

# Ajouter la nouvelle ligne au Dataframe
updated_data = pd.concat([current_data, new_row], ignore_index=True)

# Convertir les colonnes de date en chaînes de caractères pour éviter l'erreur 'is_datetimetz'
for col in updated_data.columns:
    if updated_data[col].dtype == 'datetime64[ns]':
        updated_data[col] = updated_data[col].astype(str)

# Afficher les données mises à jour
print("\nDonnées après l'ajout:")
print(updated_data.tail())
print("...")

# Redécrire les données mises à jour dans le dataset
dataset.write_with_schema(updated_data)











import dataiku
import dataikuapi
import pandas as pd

dataiku.set_remote_dss("https://dataiku-demo.dev-echonet/","InWeqTNWnL1H4r03oygjnesbSmSpXbIN",no_check_certificate=True)

# CIA de votre projet Dataiku
project_key = "API_MARKETPLACE"

# Nom de votre dataset
dataset_name = "test_prepared"

# Obtenir le dataset
dataset = dataiku.Dataset(dataset_name, project_key)

# Charger les donnes actuelles du dataset dans un DataFrame
current_data = dataset.get_dataframe()

print(current_data)

# Ajouter une nouvelle ligne (remplacez les valeurs par celles de la nouvelle ligne)
new_row = pd.DataFrame({
    "id": [31],
    "uid_user": ["user777"],
    "first_name": ["newuser"],
    "last_name": ["newuser"],
    "email": ["newuser@gmail.com"],
    "profile": ["Reader"]
})

# Ajouter la nouvelle ligne au Dataframe
current_data = pd.concat([current_data, new_row], ignore_index=True)

# Redécrire les données mises à jour dans le dataset
dataset.write_with_schema(current_data)





curl -s -u username:password "URL_du_site" | grep -o 'expires="[^"]*"' | awk -F '"' '{print $2}'

import dataikuapi

# Informations d'authentification
host = "https://YOUR_DATAIKU_INSTANCE_URL"
api_key = "YOUR_API_KEY"

# Se connecter à l'instance Dataiku
client = dataikuapi.DSSClient(host, api_key)

# Spécifier le projet et le dataset
project_key = "YOUR_PROJECT_KEY"
dataset_name = "test_prepared"

# Obtenir le dataset
project = client.get_project(project_key)
dataset = project.get_dataset(dataset_name)

# Obtenir les partitions du dataset
partitions = dataset.get_partitions()

# Obtenir les données actuelles du dataset dans un DataFrame
current_data = []
for partition in partitions:
    data_slice = partition.get_slice()
    current_data.append(data_slice.get_dataframe())

# Concaténer les données de toutes les partitions
current_data = pd.concat(current_data, ignore_index=True)

# Ajouter une nouvelle ligne au DataFrame
new_row = {
    "id": 3,
    "uid user": "user 777",
    "first name": "newuser",
    "last name": "newuser",
    "email": "newuser@gmail.com",
    "profile": "Reader"
}
current_data = current_data.append(new_row, ignore_index=True)

# Réécrire les données mises à jour dans le dataset
data_slice = dataset.get_location().get_slice()
data_slice.write_dataframe(current_data)



import dataikuapi

# Informations d'authentification
host = "https://YOUR_DATAIKU_INSTANCE_URL"
api_key = "YOUR_API_KEY"

# Se connecter à l'instance Dataiku
client = dataikuapi.DSSClient(host, api_key)

# Spécifier le projet et le dataset
project_key = "YOUR_PROJECT_KEY"
dataset_name = "test_prepared"

# Obtenir le dataset
project = client.get_project(project_key)
dataset = project.get_dataset(dataset_name)

# Charger les données actuelles du dataset dans un DataFrame
current_data = dataset.get_dataframe()

# Ajouter une nouvelle ligne au DataFrame
new_row = {
    "id": 3,
    "uid user": "user 777",
    "first name": "newuser",
    "last name": "newuser",
    "email": "newuser@gmail.com",
    "profile": "Reader"
}
current_data = current_data.append(new_row, ignore_index=True)

# Réécrire les données mises à jour dans le dataset
dataset.write_with_schema(current_data)








from fastapi import APIRouter
import dataikuapi

# Créer une instance du client Dataiku en utilisant l'hostname et la clé API
dataiku_hostname = "https://design-dataiku.dev.echonet/"
dataiku_api_key = "VOTRE_CLE_API_DATAIKU"
client = dataikuapi.DSSClient(dataiku_hostname, dataiku_api_key)

# Désactiver la vérification du certificat SSL
client._session.verify = False

# Créer un routeur FastAPI
router = APIRouter()

# Initialiser l'ID auto-incrémenté
id = 2

@router.post("/insert-into-dataset")
async def insert_into_dataset(user: UserBase):
    global id
    
    # Nom de votre projet et nom du dataset
    project_key = "API DATAIKU"
    dataset_name = "test"
    
    # Obtenir le dataset depuis Dataiku
    dataset = client.get_project(project_key).get_dataset(dataset_name)
    
    # Ajouter une nouvelle ligne avec les données de l'utilisateur
    new_row = {
        "id": id,
        "uid_user": user.uid_user,
        "first_name": user.first_name,
        "last_name": user.last_name,
        "email": user.email,
        "profile": user.profile
    }
    
    # Charger les données actuelles du dataset
    current_data = dataset.read_dataframe()
    
    # Ajouter la nouvelle ligne au DataFrame
    current_data = current_data.append(new_row, ignore_index=True)
    
    # Réécrire les données mises à jour dans le dataset
    dataset.write_with_schema(current_data)
    
    # Incrémenter l'ID auto-incrémenté
    id += 1
    
    return {"message": "Données insérées avec succès dans le dataset."}
